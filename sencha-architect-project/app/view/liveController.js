/*
 * File: app/view/liveController.js
 *
 * This file was generated by Sencha Architect
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.5.x Modern library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.5.x Modern. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RobotDriver.view.liveController', {
    extend: 'Ext.Container',
    alias: 'widget.livecontroller',

    requires: [
        'RobotDriver.view.liveControllerViewModel'
    ],

    viewModel: {
        type: 'livecontroller'
    },
    defaultListenerScope: true,

    listeners: {
        painted: 'onContainerPainted'
    },

    onContainerPainted: function(sender, element, eOpts) {
        if(this.init){
            return;
        }else{
            this.init = true;
        }

        this.activeGamepads = {};
        this.gamepadStates = {};

        var gamepadUpdate = navigator.getGamepads();
        for(var i=0; i<9; i++){
            if(gamepadUpdate[i] && gamepadUpdate[i].id){
                this.gamepadConnected({gamepad: gamepadUpdate[i]});
            }
        }

        window.addEventListener("gamepadconnected", this.gamepadConnected.bind(this));
        window.addEventListener("gamepaddisconnected", this.gamepadDisconnected.bind(this));

        this.gamePadLoop = false;
        this.startControllerLoop();
    },

    loadConfig: function(config) {
        this.mappedGamepads = config;
    },

    startControllerLoop: function() {
        if(this.gamePadLoop !== false){
            return;
        }
        this.gamePadLoop = setInterval(this.gamepadPoll.bind(this), 75);
    },

    stopControllerLoop: function() {
        if(this.gamePadLoop === false){
            return;
        }
        clearInterval(this.gamePadLoop);
        this.gamePadLoop = false;
    },

    gamepadConnected: function(e) {
        let gamepad = e.gamepad;

        this.fireEvent('gamepadConnect', gamepad);

        console.log('live gamepad connected');

        let activeIndex = 0;
        if(this.activeGamepads[gamepad.id]){
            this.activeGamepads[gamepad.id].push(gamepad);
            activeIndex = 1;
        }else{
            this.activeGamepads[gamepad.id] = [gamepad];
        }

        if(this.gamepadStates[gamepad.id]){
            this.gamepadStates[gamepad.id].push(this.getGamepadState(gamepad));
        }else{
            this.gamepadStates[gamepad.id] = [ this.getGamepadState(gamepad) ];
        }
    },

    gamepadDisconnected: function(e) {
        let gx = e.gamepad.index+e.gamepad.id;
        //TODO
        delete this.activeGamepads[gx];
        delete this.gamepadStates[gx];

        this.fireEvent('gamepadDisconnect', e.gamepad);
    },

    gamepadPoll: function() {
        var gamepadUpdate = navigator.getGamepads();

        let newGamepadStates = {};
        for(let gamepadId in this.activeGamepads){
            let gamepadIdList = this.activeGamepads[gamepadId];

            for(let gamepadIdIndex=0; gamepadIdIndex<gamepadIdList.length; gamepadIdIndex++){

                let gamepad = gamepadIdList[gamepadIdIndex];

                //is this gamepad still connected?
                if(!gamepadUpdate[gamepad.index]){
                    this.gamepadDisconnected({gamepad:gamepad});
                    return;
                }
                if(gamepadUpdate[gamepad.index].id !== gamepadId){
                    console.error('gamepad index/id ordering has changed! Refresh your browser! If problem continues, contact support!');
                    continue;
                }

                if(newGamepadStates[gamepadId]){
                    newGamepadStates[gamepadId].push(this.getGamepadState(gamepadUpdate[gamepad.index]));
                }else{
                    newGamepadStates[gamepadId] = [ this.getGamepadState(gamepadUpdate[gamepad.index]) ];
                }
            }

        }

        //detect changes!
        let axisChanges = [];
        for(let gamepadId in newGamepadStates){

            let gamepadChangeList = newGamepadStates[gamepadId];
            //console.log(gamepadIdList);

            for(let gamepadIdIndex=0; gamepadIdIndex<gamepadChangeList.length; gamepadIdIndex++){

                if(!this.gamepadStates[gamepadId][gamepadIdIndex]){
                    console.error('corresponding state not found for '+gamepadId+' index '+gamepadIdIndex+'! Refresh your browser! If problem continues, contact support!');
                    continue;
                }
                let newState = gamepadChangeList[gamepadIdIndex];
                let oldState = this.gamepadStates[gamepadId][gamepadIdIndex];

                //console.log(newState);

                for(let b in newState.buttons){
                    if(newState.buttons[b] != oldState.buttons[b]){
                        this.findMappedButton(gamepadId, gamepadIdIndex, 'button', b, newState.buttons[b], oldState.buttons[b]);
                    }
                }

                for(let a in newState.axes){
                    if(Math.abs(newState.axes[a] - oldState.axes[a]) >= 0.005){ //for axes detect change more than 0.5%
                       axisChanges.push({
                           gamepadId: gamepadId,
                           gamepadIdIndex: gamepadIdIndex,
                           mapIndex:a,
                           newValue: newState.axes[a],
                           oldValue: oldState.axes[a]
                       });

                    }//else{
                    //   newState.axes[a] = oldState.axes[a];
                    //}
                }
            }
        }

        if(axisChanges.length > 0){
            this.gamepadAxisChange(axisChanges);
        }

        this.gamepadStates = newGamepadStates;

    },

    getGamepadState: function(gamepad) {
        let state = {
            buttons:{},
            axes:{}
        };

        for(let b in gamepad.buttons){
            state.buttons[b] = gamepad.buttons[b].pressed;
        }
        for(let a in gamepad.axes){
            state.axes[a] = gamepad.axes[a];
        }

        return state;
    },

    findMappedButton: function(gamepadId, gamepadIdIndex, type, mapIndex, newValue, oldValue) {
        let args = arguments;
        let foundMap = false;

        //console.log('find mapped button');
        //console.log(gamepadId, gamepadIdIndex, type, mapIndex, newValue);

        //find mapped control, stop at first one // TODO - dont stop at first one maybe?
        Ext.each(this.mappedGamepads, function(mapped){
            //console.log(mapped);
            if(mapped.type==='item' && mapped.gamepadId == gamepadId && mapped.gamepadIdIndex == gamepadIdIndex && mapped.mapType === type && mapped.mapIndex === mapIndex){
                foundMap = mapped;
                return false;
            }
        }, this);

        if(foundMap!==false){
            this.fireEvent('action', foundMap, newValue);
        }

    },

    gamepadAxisChange: function(axisChanges) {
        let stickEvents = {};

        // axisChanges.push({
        //     gamepadId: gamepadId,
        //     gamepadIdIndex: gamepadIdIndex,
        //     mapIndex:a,
        //     newValue: newState.axes[a],
        //     oldValue: oldState.axes[a]
        // });


        //axis changes can be mapped to sliders or sticks
        for(var a in axisChanges){
            let ag = axisChanges[a];

            Ext.each(this.mappedGamepads, function(mapped){

                if(mapped.type==='stick'){
                    if(mapped.x && mapped.x.gamepadId == ag.gamepadId && mapped.x.gamepadIdIndex == ag.gamepadIdIndex && mapped.x.mapType === 'axis' && mapped.x.mapIndex === ag.mapIndex){
                        stickEvents[ag.gamepadId+ag.index+ag.mapIndex] = {
                            mapped: mapped,
                            newValue: [
                                ag.newValue,
                                this.gamepadStates[mapped.y.gamepadId][mapped.y.gamepadIdIndex].axes[mapped.y.mapIndex]
                            ]
                        };
                    }
                    if(mapped.y && mapped.y.gamepadId == ag.gamepadId && mapped.y.gamepadIdIndex == ag.gamepadIdIndex && mapped.y.mapType === 'axis' && mapped.y.mapIndex === ag.mapIndex){
                        stickEvents[ag.gamepadId+ag.index+ag.mapIndex] = {
                            mapped: mapped,
                            newValue: [
                                this.gamepadStates[mapped.x.gamepadId][mapped.x.gamepadIdIndex].axes[mapped.x.mapIndex],
                                ag.newValue
                            ]
                        };
                    }
                }else{
                    //if not stick mapped.type will be 'item'
                    if(mapped.gamepadId == ag.gamepadId && mapped.gamepadIdIndex == ag.gamepadIdIndex && mapped.mapType === 'axis' && mapped.mapIndex === ag.mapIndex){
                        this.fireEvent('action', mapped, ag.newValue);
                    }
                }


            }, this);
        }
        for(var e in stickEvents){
            this.fireEvent('action', stickEvents[e].mapped, stickEvents[e].newValue);
        }

    }

});